---
title: "Weighted Gene Network Correlation Analysis"
author: "Victoria French, CeCe Gerstenbacher, Warrenkevin Henderson, and Elizabeth Varghese"
date: "11/29/2021"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    theme: yeti 
---

# Weighted Gene Correlation Network Analysis

![alt text](https://i.gifer.com/J4x.gif)

Objective: 

WGCNA is a variation of correlation network construction. Networks are visual representations of interactions between 'nodes' in a system. The nodes in Weighted Gene Correlation Network Analysis are individual genes. Therefore WGCNA is a great tool for visualizing patterns and relationships between gene expression profiles (transcripts). WGCNA can: 

1) Identify clusters of similarly expressed genes
2) Identify highly connected 'hub' genes
3) Relate clusters (modules) of genes to one another 
4) Relate gene expression to external sample traits. 

All of these are important for identifying potential candidate genes associated with measured traits as well as identifying genes that are consistently co-expressed and could be contributing to similar molecular pathways. Using WGCNA is also extremely useful statistically as it accounts for inter-individual variation in gene expression and alleviates issues associated with multiple testing. 

## Setup 

Before running through the following code you will need to install the following packages: {BiocManager}, {WGCNA}, {flashClust}

BiocManager is a package that will facilitate the installation of the other two packages as they are not updated to the current version of R. We have also found while running this module it is best to update your R and Rstudio to the most current version. 

```{r}
#install.packages('BiocManager')
#library(BiocManager)
#BiocManager::install('WGCNA')
#BiocManager::install('flashClust')
```

---

**NOTE**: Installing these packages will result in prompts that require you to input additional commands at the command line. 

---

```{r, warning=FALSE}
library(WGCNA)
library(flashClust)
library(curl)
```

## Data input 

WGCNA utilizes gene expression data from micro array or RNA-seq experiments. For a basic understanding of these experiments you can view [this educational video](https://www.youtube.com/watch?v=Hv5flUOsE0s). 

We are utilizing the data set available from the authors of the WGCNA pathway (Steve Hovarth and Peter Langfelder) that they utilize in their [tutorial](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/). 

For this tutorial we will be reading in the data set from our github page. 

```{r}
d <- curl('https://raw.githubusercontent.com/vfrench-397/AN588_RVignette/main/FemaleLiver-Data/LiverFemale3600.csv')
liver.data <- read.csv(file = d, stringsAsFactors = FALSE, header = TRUE)
head(liver.data)
```

This .csv file contains quantified and normalized gene expression data from livers of several F2 female mice. 

![alt text](https://66.media.tumblr.com/4e94770dc5af4083d5f63f16b4cbdbb1/tumblr_n4chqvOoOF1tzq2cgo4_250.gif)

For the purposes of this tutorial it is just important to understand the values in our data set are gene expression levels relative to a control.  

---

**NOTE**: For information on how to generate expression data from raw sequence reads, there is a great [online course](https://www.singlecellcourse.org/scrna-seq-analysis-with-bioconductor.html) available from the Sanger Institute detailing the process. 

---

The data set also contains a lot of additional trait data not relevant to our analysis and is in an incompatible format for the WGCNA pathway. Therefore we need to reformat the data so it is conducive to the WGCNA package functions. 

## Cleaning Data 

First, the additional trait data needs to be removed.

```{r}
expression.data <- liver.data[,-c(1:8)] #removing variables not holding expression data
```

Then, the data frame needs to be transformed so the rows represent samples instead of gene sequences and the columns represent gene sequences instead of samples.

```{r}
expression.data <- as.data.frame(t(expression.data)) #transforming the data.frame so columns now represent genes and rows represent samples
names(expression.data) <- liver.data$substanceBXH
#renaming the columns so we don't lose the gene IDs
```

## Identifying Outliers

### Identifying Outlier Genes 

The WGCNA package has a built in function to identify outlier genes called goodSampleGenes(). The function checks the data and returns a list object of samples and genes that pass its filtering criteria. You can adjust how strict the filtering process is by changing the default of the arguments (which can be found under the goodSampleGene documentation, ?goodSampleGenes).  

```{r}
gsg <-goodSamplesGenes(expression.data)
summary(gsg)
```

By viewing the gsg list object you can see it contains 3 logical vectors (good genes, good samples and allOK). If we want to see if the function identified any possible outlier all we have to do is evaluate the allOK vector.

```{r}
gsg$allOK
```


If the allOK object returns true, which it does in this case, there are no outliers present. If it doesn't return true, we need to filter out the outliers manually using the following code. 

```{r}
if (!gsg$allOK)
{
if (sum(!gsg$goodGenes)>0) 
printFlush(paste("Removing genes:", paste(names(expression.data)[!gsg$goodGenes], collapse = ", "))); #Identifies and prints outlier genes
if (sum(!gsg$goodSamples)>0)
printFlush(paste("Removing samples:", paste(rownames(expression.data)[!gsg$goodSamples], collapse = ", "))); #Identifies and prints oulier samples
expression.data <- expression.data[gsg$goodSamples == TRUE, gsg$goodGenes == TRUE] # Removes the offending genes and samples from the data
}
```

### Identifying outlier samples 

You can identify outlier samples by using hierarchical clustering. It is probably beneficial to review the [clustering module](https://fuzzyatelin.github.io/bioanth-stats/module-25/module-25.html) as clustering is used several times within this pathway. 
```{r}
sampleTree <- hclust(dist(expression.data), method = "average") #Clustering samples based on distance 

#Setting the graphical parameters
par(cex = 0.6);
par(mar = c(0,4,2,0))

#Plotting the cluster dendrogram
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
```

Here you can see sample F2_221 seems to be distant from all of the other samples indicating it is likely an outlier sample. 

We can remove the outlier using a cutree function.

```{r}
#Setting the graphical parameters
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
#draw on line to show cutoff height
abline(h = 15, col = "red");
```
In our case it looks like the cut height of 15 would cut F2_221 and retain the rest of the samples. 

```{r}
cut.sampleTree <- cutreeStatic(sampleTree, cutHeight = 15, minSize = 10) #returns numeric vector
#Remove outlier
expression.data <- expression.data[cut.sampleTree==1, ]
```

## Network Construction

### Pairwise Gene Co-expression similarity

Once we have purged the outliers, we can begin our network construction. The first step in network construction is to identify some sort of similarity measurement between pairs of genes. A similarity measurement represents the concordance of gene expression profiles across samples. In WGCNA the similarity measurement for each pair of genes (gene i and gene j) is denoted by their [Pearson correlation coefficient](https://fuzzyatelin.github.io/bioanth-stats/module-12/module-12.html). 

#### Unsigned Networks 

For unsigned networks we take the absolute value of the correlation. So the similarity measurement is denoted by: 

sij=|cor(i, j)|

Although, it is more common practice to create a signed network. As unsigned networks make biological interpretation of results extremely difficult. If the network is unsigned, we do not know if the gene is up or down regulated in the sample trait, just that its expression is significantly different. 

#### Signed Networks 

The similarity measurement for a signed network is calculated as follows:

sij = .5 + .5 * cor(i,j)

### Adjacency: Pairwise connection

The next step after calculating the similarity measurement for each gene pair is to translate that similarity measurement into the gene pairs adjacency to generate an adjacency matrix. Adjacency is the assignment of a connection strength based on the co-expression similarity measurement (Pearson correlation coefficient). Nodes are considered connected if they have a significant pairwise correlation association. 

The generation of the adjacency matrix uses an adjacency function for its conversion. The function and its parameters vary based on what type of network construction you are trying to perform. 

#### Unweighted Networks

  - In unweighted networks, the adjacency matrix indicates whether or not a pair of nodes are connected in a binary fashion 

- Unweighted networks utilize the signum function with the input of a hard threshold parameter τ
  
  aij = signum (sij, τ) ≡{1 if sij ≥ τ 
                          0 if sij < τ}
                          
Here you can see the similarity measurement is compared to a hard threshold parameter of τ. If the similarity measurement is greater than τ the pair of genes are assigned a value of 1 (connected) in the adjacency matrix.  If the similarity measurement is less than τ, the pair is assigned a 0 (not connected) in the adjacency matrix. 

--- 

**NOTE**: Utilizing a hard threshold can mean you lose a lot of information. If you set the threshold to .9, even if a pair has a similarity of .89999999999 they will be considered to have no connection. 

---

#### Weighted Networks 

In weighted networks the adjacency/connection is not binary and therefore can also distinguish the strength of connection.

- weighted networks utilize a power function based on a soft threshold parameter β 
  
  aij = power (sij,β) = |sij|^β

Here you can see the adjacency matrix value is calculated by raising the similarity measurement to the defined threshold parameter β. 

The WGCNA package has a built in function called adjacency() that will generate the pairwise similarity measurements and the adjacency matrix but before we call the function we need to identify what value we want to use for our soft threshold parameter.

#### Determining the soft power threshold 

The choice of the threshold parameter determines the sensitivity and specificity of the pairwise connection strengths (adjacency). 

To determine the β parameter in a weighted network analysis we try to maximize a model fit (R^2 value under a linear regression analysis) under a scale free topology model, while minimizing the number of connections lost when fitting the model (maintaining a high mean number of connections). As R^2 values approach 1, we usually see networks with very few connections. Usually this happy medium occurs at R^2 of > .8.  

The scale-free topology is used because it is based on the idea that the probability that a node (gene) is connected with k other nodes (genes) decays as a power law:

p(k)~ k^(-γ)

Note: [Here](https://www-degruyter-com.ezproxy.bu.edu/document/doi/10.2202/1544-6115.1128/html) is a great publication for more information about scale free topology model assumptions.

Again the WGCNA package has a built in function that helps us determine what the appropriate β parameter will be to calculate our adjacency matrix. The pickSoftThreshold() function calculates multiple networks all based on different β values and returns a data frame with the R^2 values for the networks scale-free topology model fit as well as the mean connectivity measures.

```{r}
spt <- pickSoftThreshold(expression.data) 
spt
```

We can then plot this data frame to better visualize what β value we should choose. 

---

**REMINDER**: We should be maximizing the R^2 value and minimizing mean connectivity.

---

Plot the R^2 values as a function of the soft thresholds 

```{r}
plot(spt$fitIndices[,1],spt$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"))
text(spt$fitIndices[,1],spt$fitIndices[,2],col="red")
abline(h=0.80,col="red")
```

Plot mean connectivity as a function of soft thresholds

```{r}
plot(spt$fitIndices[,1], spt$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(spt$fitIndices[,1], spt$fitIndices[,5], labels= spt$fitIndices[,1],col="red")
```

We can determine our soft power threshold should be set to 6 as it is the spt that retains the highest mean connectivity while reaching an R^2 value above 0.80. 

---

**NOTE**: the higher the β value, the stronger the connection strength will be of highly correlated gene expression profiles and the more devalued low correlations will be.

---

#### Calling the adjacency function

Now that we have our soft threshold power determined we can call on the adjacency() function of the WGCNA package. 

---

**REMINDER**: This function calculates the similarity measurement and transforms the similarity by the adjacency function and generates a weighted network adjacency matrix.

---

```{r}
softPower <- 6
adjacency <- adjacency(expression.data, power = softPower)
```

## Module Construction

### Defining Dissimilarity 

Once our network is constructed, we can begin to extract some meaningful relationships. We can use hierarchical clustering yet again to cluster the network into modules, groups of similarly expressed genes. 

In order to utilize the clustering functions in R we must transform our adjacency matrix into measures of gene dissimilarity (distance of a gene from every other gene in the system). 

#### Topological Overlap Matrix 

The TOM-based dissimilarity is preferentially used over dissimilarity based on correlation coefficients because TOM-based dissimilarity generates more distinct modules. 

Note: [Here](https://www-degruyter-com.ezproxy.bu.edu/document/doi/10.2202/1544-6115.1128/html) is a great publication for information about why topological overlap is used. 

To convert the adjacency matrix into a TOM similarity matrix we can call the WGCNA function TOMsimilarity(). 

```{r}
TOM <- TOMsimilarity(adjacency)
```
## Challenge #?
Our current matrix gives us the similarity between genes. How should we convert this into measures of dissimilarity? 

### Answer: 
To convert this matrix into a dissimilarity matrix you can subtract the TOM object from 1. 

```{r}
TOM.dissimilarity <- 1-TOM
```

### Hierarchical Clustering Analysis 

The dissimilarity or distance measures are then clustered using linkage hierarchical clustering and a dendrogram (cluster tree) of genes is constructed.

```{r}
#creating the dendrogram 
geneTree <- hclust(as.dist(TOM.dissimilarity), method = "average") 
```

```{r}
#plotting the dendrogram
sizeGrWindow(12,9)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity", 
labels = FALSE, hang = 0.04)
```
To identify modules from this gene dendrogram, we will use the cutreeDynamic() function. This will allow us to set a minimum cluster size. For genomic data like this it is more beneficial to set mminimum module sizes relatively high as we are working with high loads of data. The authors of WGCNA recommend to start at a minClusterSize = 30. 

```{r}
Modules <- cutreeDynamic(dendro = geneTree, distM = TOM.dissimilarity, deepSplit = 2, pamRespectsDendro = FALSE, minClusterSize = 30)
table(Modules) #returns a table of the counts of factor levels in an object. In this case how many genes are assigned to each created module. 
```

Here we can see 22 modules were created. The Label 0 Module is reserved for unassigned genes (genes that do not fit in any module). 

We can now plot the module assignment under the gene dendrogram for visualization. 

```{r}
ModuleColors <- labels2colors(Modules) #assigns each module number a color
table(ModuleColors) #returns the counts for each color (aka the number of genes within each module)
```


```{r}
#plots the gene dendrogram with the module colors
plotDendroAndColors(geneTree, ModuleColors,"Module",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05,
main = "Gene dendrogram and module colors")
```

### Module Eigengene identification

A ME (Module Eigengene) is the standardized gene expression profile for a given module.

To identify the Module Eigengene we can call on the expression data into the moduleEigengenes function. 

```{r}
MElist <- moduleEigengenes(expression.data, colors = ModuleColors) 
MEs <- MElist$eigengenes 
MEs
```
We have now identified the eigengenes for our data. 

## Module Merging 

To further condense the clusters (branches) into more meaningful modules you can cluster modules based on pairwise eigengene correlations and merge the modules that have similar expression profiles. 

---

**REMINDER**: An eigengene is the gene whose expression is representative of the the majority of genes expressed within a module. 

---

In order to do cluster analysis we must first find a measurement of dissimilarity (distance) between module eigengenes. 

However, because we have missing values present in our input variable, we will need to add a line of code  (use="complete"). This command removes rows of the matrix which have NA values. Removing these NAs allows ME.dissimilarity to run. This may or may not be necessary depending on your data set. 

```{r}
ME.dissimilarity = 1-cor(MElist$eigengenes, use="complete") #Calculate eigengene dissimilarity
```

Now, using our new found measurements of dissimilarity, we will construct a cluster tree. We will also be adding a line at the height of .25. This height corresponds to a correlation of over 75%. Any branches below this line are more than 75% related, and we will thus be merging them!

```{r}
METree = hclust(as.dist(ME.dissimilarity), method = "average") #Clustering eigengenes 
par(mar = c(0,4,2,0)) #seting margin sizes
par(cex = 0.6);#scaling the graphic
plot(METree)
abline(h=.25, col = "red") #a height of .25 corresponds to correlation of .75
```
 
This figure shows all of the modules which are more than 75% similar. For example you can see that MEcyan and MEpurple are more than 75% similar. Now we will merge these two modules, and others like them using the mergeCloseModules command 

```{r}
merge <- mergeCloseModules(expression.data, ModuleColors, cutHeight = .25)
# The merged module colors, assigning one color to each module
mergedColors = merge$colors
# Eigengenes of the new merged modules
mergedMEs = merge$newMEs
```

The similar modules are now merged! Lets compare them with our original modules by creating another dendrogram

### Challenge 

Using the knowledge you gained from the Hierarchical Clustering Analysis section, create a dendrogram which shows both the original AND merged module colors. 

#### Answer:

```{r}
plotDendroAndColors(geneTree, cbind(ModuleColors, mergedColors), 
c("Original Module", "Merged Module"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05,
main = "Gene dendrogram and module colors for original and merged modules")
```

Coooollioo! you can see that generally, there are less colors in the merged modules row, showing that our modules which were more than 75% similar have merged. For example, the lime green and red section merged into one large lime green section. This new merged output is cleaner and further identifies groups of highly correlated genes which co-occur across samples.

## External Trait Matching

Once you have constructed the network (the adjacency matrix) and divided it into meaningful modules, you can begin to relate the network to external traits. 

### Data Input 

Start by reading in Trait Data Table

```{r}
t <- curl('https://raw.githubusercontent.com/vfrench-397/AN588_RVignette/main/FemaleLiver-Data/ClinicalTraits.csv')
traitData <- read.csv(t, header = TRUE, stringsAsFactors = FALSE)
head(traitData)
```

Cleaning Trait Data 

```{r}
allTraits <- traitData[, -c(31, 16)] #removing notes and comments sections 
allTraits <- allTraits[, c(2, 11:36) ] #pulling out only continuous traits 
```

Forming a data frame analagous to expression data that can hold clinical traits 
```{r}
Samples <- rownames(expression.data)
traitRows <- match(Samples, allTraits$Mice)
datTraits <- allTraits[traitRows, -1]
rownames(datTraits) <- allTraits[traitRows, 1]
```

visualize how the clinical traits relate to the sample dendrogram
Vicky: Do we need this? 

```{r}
# Re-cluster samples
sampleTree2 = hclust(dist(datTraits), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE);
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
groupLabels = names(datTraits),
main = "Sample dendrogram and trait heatmap")
```


### Module-Trait associations

Identify modules that are significantly associated with external traits by correlating the trait with eigengenes (summary or representative gene for each module) and look at the significance of the correlation.


Vicky: datExpr already defined, It is just renamed expression.data earlier in the script for clarity
Defining datExpr
clust = cutreeStatic(sampleTree, cutHeight = 15, minSize = 10)
table(clust)
keepSamples = (clust==1)
datExpr = datExpr0[keepSamples, ]
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)


```{r}
# Define numbers of genes and samples
nGenes = ncol(expression.data)
nSamples = nrow(expression.data)
# Recalculate Module Eigengenes with color labels
#MEs0 = moduleEigengenes(datExpr, mergedColors)$eigengenes
#MEs = orderMEs(MEs0)
module.trait.correlation = cor(mergedMEs, datTraits, use = "p")
module.trait.Pvalue = corPvalueStudent(module.trait.correlation, nSamples)
```

```{r}
# Will display correlations and their p-values
textMatrix = paste(signif(module.trait.correlation, 2), "\n(",
signif(module.trait.Pvalue, 1), ")", sep = "");
dim(textMatrix) = dim(module.trait.correlation)
par(mar = c(6, 8.5, 4, 4))
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = module.trait.correlation,
xLabels = names(datTraits),
yLabels = names(mergedMEs),
ySymbols = names(mergedMEs),
colorLabels = FALSE,
colors = blueWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),
main = paste("Module-trait relationships"))
```
Those with strong positive correlations are shaded a darker red while those with stronger negative correlations become more blue. The associated p value is also logged in parentheses underneath the correlation strength. 

### Target Gene Identification 

As was discussed in the introduction, you can now identify novel target genes in molecular pathways by looking at the genes intramodular connectivity and its gene significance. 

We quantify associations of individual genes with our trait of interest (weight) by defining Gene Significance GS as (the absolute value of) the correlation between the gene and the trait. For each module, we also define a quantitative measure of module membership MM as the correlation of the module eigengene and the gene expression profile. This allows us to quantify the similarity of all genes on the array to every module.


  Connectivity - how connected is that specific node (how many nodes have high correlation with that node). High connectivity indicates a hub gene (central to many nodes). 
  - high connectivity can be identified by a high topological overlap
  
  Whole Network connectivity - a measure for how well the node is connected throughout the entire system
  
  Intramodular connectivity - a measure for how well that node belongs to its module. How well that node is connected within its module. 

  Gene significance - (the pairwise correlation between a sample trait and the eigengene, and the p-value for each module). Module eigengenes correlated with the sample trait to determine the eigengene significance 

```{r}
# Define variable weight containing the weight column of datTrait
weight = as.data.frame(datTraits$weight_g)
names(weight) = "weight"
# names (colors) of the modules
modNames = substring(names(mergedMEs), 3)

geneModuleMembership = as.data.frame(cor(expression.data, mergedMEs, use = "p"))
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))
names(geneModuleMembership) = paste("MM", modNames, sep="")
names(MMPvalue) = paste("p.MM", modNames, sep="")


geneTraitSignificance = as.data.frame(cor(expression.data, weight, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(weight), sep="")
names(GSPvalue) = paste("p.GS.", names(weight), sep="")
head(GSPvalue)
```


Intramodular analysis: identifying genes with high GS and MM

Using the GS and MM measures, we can identify genes that have a high significance for weight as well as high module membership in interesting modules. As an example, we look at the magenta module that has the highest significant association with weight (.59). We plot a scatter plot of Gene Significance vs. Module Membership in the brown module:

```{r}
module = "magenta"
column = match(module, modNames)
moduleGenes = mergedColors==module
verboseScatterplot(abs(geneModuleMembership[moduleGenes,column]),
abs(geneTraitSignificance[moduleGenes,1]),
xlab = paste("Module Membership in", module, "module"),
ylab = "Gene significance for body weight",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
```

Clearly, GS and MM are highly correlated,illustrating that genes highly significantly associated with a trait are often also the most important (central) elements of modules associated with the trait. 

### Challenge 
Try this analysis for other significant trait/module correlations from the heat map. Or with another trait. 

#### Answer



We have found modules with high association with our trait of interest, and have identified their central players by the Module Membership measure

## References: 

1. Hovarth's original Tutorial 
- https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/
2. R in Action Chapter 16 
3. Langfelder and Horvath 2008 
- https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2631488/
4. Horvath and Zhang (2005) doi: 10.2202/1544-6115.1128
https://www-degruyter-com.ezproxy.bu.edu/document/doi/10.2202/1544-6115.1128/html

